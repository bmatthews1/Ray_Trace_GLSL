<script src="den.js/den.js"></script>
<script src="ben.js/ben.js"></script>
<script>
  Den();
  Ben();

  //-- texture definitions --------------------------------------------------
    let size      = [innerWidth, innerHeight];
    let outColor  = v4tex(size);
    let buffer    = v4tex(size);
    let noise     = v4tex(size);
    let skybox    = imgtex("sky.jpg");
    // let skybox    = imgtex("stars.jpg");

    let modes = ["sphere","environment", "equation"];
    let mode  = 0;
    let prevVals = modes.map(i => new Object());

    let rotation = Matrix4.identity;
    let camera_lerp = .05;

  //-- fragment shader header ----------------------------------------------- 
    let header = `
      vec3 quadraticSolve(float a, float b, float c){
        float delta = (b*b - a*c*4.);

        if      (delta >  0.) return vec3(2., (-b + sqrt(delta))/2.*a, (-b - sqrt(delta))/2.*a);
        else if (delta == 0.) return vec3(1., -b/(a*2.), 0.);
        else return vec3(0);
      }

      float eqSolve(vec3 o, vec3 d, int s){
        float z = 0.;
        vec3 d2 = d;
        for (int i = 0;  i < s; i++){
          float n = o.z/d2.z;
            vec3 p = o+d2*n;
            z = (1.+sin(p.x*p.x*p.y*p.y))/2.;
            p.z = z;
            d2 = normalize(p-o);
        }
        return z;
      }
    `

    let ray_setup = `
      vec3 origin = (rotation*vec4(pixel + rand2() - res/2., camera*ratio, 0.)).xyz;
      vec3 cam    = (rotation*vec4(0., 0., camera, 0.)).xyz;
      vec3 ray    = normalize(origin - cam);
      vec3 light  = vec3(1);
    `

    let main_header = `
      float n = thisTexel(noise).x;
        vec4  i = thisTexel(image);

        if (n > speed){
          vec3 origin = (rotation*vec4(pixel + rand2() - res/2., camera*ratio, 0.)).xyz;
          vec3 cam    = (rotation*vec4(0., 0., camera, 0.)).xyz;
          vec3 ray    = normalize(origin - cam);
          vec3 light  = vec3(1);
    `

    let main_footer = `
          i.a += 1.;
          outColor = vec4(i.rgb + col.rgb, i.a);
        }
        else outColor = i;
    `

  //-- pre calculations -----------------------------------------------------
    let getRotationMatrix = (xAngle, yAngle) => {
      let rotX =  Matrix4.identity.rotate(-yAngle, 1, 0, 0);
      let rotY =  Matrix4.identity.rotate(-xAngle, 0, 1, 0);
      return rotX.times(rotY);
    }

    let updateRotation = (xAngle, yAngle) => {
      rotation = rotation.times(getRotationMatrix(mouseDiff.x, -mouseDiff.y));
      mouseDiff = mouseDiff.lerpTo([0, 0], camera_lerp);
      reset();
    }

    let reset = () => {
      buffer.clear();
    }

  //-- rendering ------------------------------------------------------------
    let renderFrag = (inner_frag) => {
      buffer.run({
        noise     : sampler | vec4,
        skybox    : sampler | vec4,
        camera    : uniform | float,
        ratio     : uniform | float,
        radius    : uniform | float,
        m         : uniform | int,
        speed     : uniform | float,
        rotation  : uniform | mat4,

        frag : 
        `
        ${header}

        void main(){
          ${main_header}
            ${inner_frag}
          ${main_footer}
        }`
      },{noise, skybox, rotation, m:mode, ...params})
    }

    let render = () => {
      //let rotation = getRotationMatrix(params.xAngle, params.yAngle);
      noise.noise({scale:1, quality:1, speed:10});
      
      switch(mode){
        case 0 : renderSphere();      break;
        case 1 : renderEnvironment(); break;
        case 2 : renderEquation();    break;
      }
    }

    let renderSphere = () => {
      renderFrag(`
        vec3 col = vec3(.5);
        float A = dot(ray,    ray);
        float B = dot(origin, ray)*2.;
        float C = dot(origin, origin) - radius*radius;

        vec3 qs = quadraticSolve(A, B, C);

        if (qs.x > 0.){
          vec3 p1 = origin + ray*qs.y;
          p1 = (p1+1.);
          vec3 p2 = origin + ray*qs.z;
          col += vec3(p1/radius);
        }
      `)
    }

    let renderEnvironment = () => {
      renderFrag(`
        float u = atan2(ray.z, ray.x)/tau - .5;
        float v = ray.y/2. + .5;
        vec3 col = texture(skybox, vec2(u, v)).rgb;

        vec3 p   = vec3(0);

        float A = dot(ray,    ray);
        float B = dot(origin, ray)*2.;
        float C = dot(origin, origin) - radius*radius;

        vec3 qs = quadraticSolve(A, B, C);

        if (qs.x > 0.){
          vec3 normal = normalize(origin + ray*qs.z);
          vec3 reflection = ray - 2.*dot(ray, normal)*normal;

          u = atan2(reflection.z, reflection.x)/tau - .5;
          v = reflection.y/2. + .5;
          col = mix(vec3(.5),texture(skybox, vec2(u, v)).rgb, .9);
        }    
      `)
    }

    let renderEquation = () => {
      renderFrag(`
        origin = vec3(pixel+rand2()-res/2., camera)/50.;
        ray    = normalize(origin);
        vec3 col = vec3(eqSolve(origin, ray, 1));
      `)
    }

  //-- controls -------------------------------------------------------------
    addControls(
      {onChange(){reset()},name:"camera", alias:"camera distance", max:2000, val:1000},
      {onChange(){reset()},name:"ratio" , alias:"camera plane"},
      {onChange(){reset()},name:"radius"   ,max:1000, val:300},
      {onChange(){reset()},name:"speed", alias:"random thresh", val:.2, max:.74},

      {name:"modes", alias:"mode",options:modes, onChange:function(){
        prevVals[mode] = {...params, rotation:rotation.times(Matrix4.identity)};
        mode = modes.indexOf(params.modes);
        setParams(prevVals[mode])
        if (prevVals[mode].rotation) rotation = prevVals[mode].rotation;
        reset();
      }},
    ); showControls();

    let mouse  = size.div(2);
    let pmouse = size.div(2);
    let mouseDiff = [0, 0];
    let down   = false;

  //-- main loop ------------------------------------------------------------
    autoLoop(() => {
      if (mouseDiff.mag > .01) updateRotation();
      render();
      outColor.setTo(buffer).io(`o = vec4(i.rgb/i.a, 1.)`);
      outColor.blit();
    })

  //-- mouse updates --------------------------------------------------------
    onpointerdown = evt => {down = true;}

    onpointermove = evt => {
      pmouse = [...mouse];
      mouse  = [evt.clientX, size.y - evt.clientY];
      if (down){
        mouseDiff = pmouse.minus(mouse).div(100);
      }
    }

    onpointerup = evt => {down = false;}

    onWheel = evt => {
      let amt = 1;
      if (evt.deltaY < 0) amt = .9;
      else amt = 1.1; 
      setParams({camera:params.camera*amt})
      reset();
    };
</script>